= Projet Euler - Numéros pairs de Fibonacci
:nofooter:
:stylesdir: ../../css/
:stylesheet: core.min.css
:source-highlighter: highlightjs
:highlightjsdir: ../../highlight

== 15 Octobre 2019

[quote]
Each new term in the Fibonacci sequence is generated by adding the previous two terms.
By starting with 1 and 2, the first 10 terms will be: 1, 2, 3, 5, 8, 13, 21, 34, 55, 89...
By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.

[source,kotlin]
----
fun main() {
    val fibonacci = generateSequence(1 to 1) { it.second to it.first + it.second }
        .map { it.first }

    fibonacci.takeWhile { it <= 4_000_000 }
        .filter { it.isEven }
        .sum()
        .also { println(it) }
    }

private val Int.isEven: Boolean
    inline get() = this % 2 == 0
----

Vous devez trouver des multiples de 2 dans la link:https://en.wikipedia.org/wiki/Fibonacci_number[suite de Fibonacci].
Dans cette suite, chaque nombre est la somme des deux précédents.
Les valeurs de la séquence ne doivent pas dépasser quatre millions.

Kotlin nous permet d'utiliser une link:https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/-sequence/index.html[Sequence].
Une `Sequence` est une collection évaluée en différé. L'link:https://en.wikipedia.org/wiki/Lazy_initialization[initialisation différée] signifie que la création d'objet est différée jusqu'à sa première utilisation.
Cette technique est utile si vous souhaitez améliorer les performances, éviter le gaspillage de calculs et réduire les besoins en mémoire du programme.

La méthode `generateSequence` prend deux paramètres.
Le premier est une graine.
Il s'agit de la valeur de départ de la séquence.
Dans notre exemple, nous avons commencé avec deux 1. En effet, nous avons défini une link:https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-pair/index.html[Pair] qui prend deux `Int`.

[source,kotlin]
----
val pair: Pair<Int, Int> = 1 to 1 // équivalent de Pair(1, 1)
----

Le deuxième argument est une fonction appelée pour calculer la valeur suivante en fonction de la précédente, à chaque itération.
Dans notre cas, nous devons créer une autre paire à l'aide de notre graine.
Donc, nous avons une nouvelle paire avec la dernière valeur et la somme des deux valeurs dans la paire précédente.

[source,kotlin]
----
// Pair(1, 1) puis Pair(1, 2) puis Pair(2, 3) puis Pair(3, 5), ...
val newPair = it.second to it.first + it.second
----

Enfin, nous mappons sur la première valeur d'une paire et nous avons une séquence avec seulement des entiers, et donc, plus de paires.
C'est notre séquence de Fibonacci.

La méthode `takeWhile` nous permet de donner un prédicat à la `Sequence`.
Avec cela, nous pouvons vérifier que les valeurs ne dépassent pas quatre millions.
Une autre vérification est demandée : vérifiez si le nombre est pair.
Pour cela, nous utilisons une propriété inline comme dans le premier problème.

La méthode `sum` est une méthode terminée car elle ne renvoie pas de `Sequence`.
Lorsque cette méthode est déclenchée, le programme va initialiser notre collection paresseuse.
